<!DOCTYPE html>
<html lang="en">

<head>

    <title>Filter and Convert CSV to GeoJSON and KML | Digital Periegesis</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="language" content="en" />
    <meta name="creator" content="Public Sphere" />
    <meta name="title" content="Filter and Convert CSV to GeoJSON and KML | Digital Periegesis" />
    <meta name="description"
        content="Convert CSV files with geographic point data to GeoJSON and KML formats. Supports filtering by Book, Type, and Region, and generates two KML versions for mapping platforms." />
    <meta name="keywords"
        content="CSV to GeoJSON, CSV to KML, convert CSV, geographic data, latitude longitude, Digital Periegesis, KML ExtendedData, Google Maps" />

    <meta property="og:type" content="website" />
    <meta property="og:title" content="Filter and Convert CSV to GeoJSON and KML | Digital Periegesis" />
    <meta property="og:description"
        content="Convert and filter CSV files with geographic point data into GeoJSON and KML formats. Includes dual KML output for mapping platforms." />
    <meta property="og:site_name" content="Digital Periegesis" />
    <meta property="og:url" content="https://www.periegesis.org/en/map_tools.php?p=filter-csv-to-geojson-kml" />

    <link rel="canonical" href="https://www.periegesis.org/en/map_tools.php?p=filter-csv-to-geojson-kml" />

    <link rel="icon" type="image/svg+xml" href="../images/logo/favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;
            padding: 0;
            margin: 0;
            margin-bottom: 4rem;
        }

        h2 {
            text-align: center;
        }

        .header {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0.5rem 20%;
            background-color: #003D7A;
            color: #ffffffcc;
        }

        .fixed {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
        }

        .fixed a {
            color: #ffffffcc;
            text-decoration: none;
        }

        .fixed a:hover {
            color: #ffffff;
        }

        .flex {
            display: flex;
            justify-content: space-around;
            margin: 1rem auto;
        }

        .flex_center {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 0 1rem;
            margin: 0 auto;
            background-color: #eee;
            border: 1px solid #ddd;
        }

        .flex_column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            gap: 0 1rem;
            margin: 0 auto;
        }

        input,
        button,
        select {
            font-size: 1rem;
            padding: 0.5rem;
            margin: 0.5em 0;
        }

        input[type="file"] {
            font-size: 1rem;
            padding: 0.4rem;
            background: #fff;
            color: #003D7A;
        }

        .bg {
            background-color: #f6f6f6;
        }

        .bg a {
            margin: 1rem 0;
            text-decoration: none;
        }

        .container {
            width: 100%;
            max-width: 1024px;
            padding: 1rem;
            margin: 0 auto;
            background-color: #f6f6f6;
            border: 1px solid #ddd;
            line-height: 1.5;
        }

        pre {
            background: #f4f4f4;
            padding: 1em;
            overflow-x: auto;
        }

        #ShowHide {
            font-size: 2rem;
            line-height: 50%;
            padding: 0 1rem;
            margin: 0;
            background: #003D7A;
            color: #ffffffcc;
            cursor: pointer;
        }

        .hide::before {
            content: " \23F6";
        }

        .show::before {
            content: "\23F7";
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="fixed">
            <a title="Home to Digital Periegesis" href="index.php">dp</a><br>
            <a title="Search in Maps" href="map_search.php">SM</a>
        </div>
        <select id="Server_CSVFile" name="Server_CSVFile">
            <option value="">Convert Server CSV File</option>
        </select>
        <div>
            <input type="file" id="User_CSVFile" accept=".csv">
            <button onclick="convert_CSVToGeoJSON()">Convert Local CSV</button>
        </div>
    </div>
    <div class="flex_center">
        <label id="bookFilterContainer">Filter by Book:
            <select id="bookFilter">
                <option value="">(All)</option>
            </select>
        </label>
        <label id="typeFilterContainer">Filter by Type:
            <select id="typeFilter">
                <option value="">(All)</option>
            </select>
        </label>
        <label id="regionFilterContainer">Filter by Region:
            <select id="regionFilter">
                <option value="">(All)</option>
            </select>
        </label>
    </div>
    <h2>
        Filter and Convert CSV to GeoJSON and KML Files
        <span id="ShowHide" class="hide" title="Show/Hide Information"></span>
    </h2>

    <div class="flex_column" id="info">
        <div class="container">
            <p><b>Conversion</b> supports CSV files containing <b>Geometric Points</b> defined by separate fields for
                <b>Latitude</b> and <b>Longitude</b>. The following <b>case-insensitive</b> field name variants are
                accepted:
            </p>
            <ul>
                <li><b>Latitude:</b> lat, Lat, LAT, latitude, Latitude, LATITUDE</li>
                <li><b>Longitude:</b> lon, Lon, LON, lng, Lng, LNG, long, Long, LONG, longitude, Longitude, LONGITUDE
                </li>
            </ul>

            <p><b>Filtering</b> presupposes that the CSV file includes all or any of the predefined <b>case-insensitive</b>
                field names: <b>Passages</b>, <b>Type</b>, and <b>Region</b>.
            </p>
            <ul>
                <li>If filtering fields are absent, the entire dataset will be converted to GeoJSON and KML without
                    filtering options.</li>
                <li>If filtering fields are present, all their <b>unique values</b> in the dataset are displayed as options in their respective select element.</li>
                <li>You can combine filtering by choosing options from all fields.</li>
            </ul>

            <p>You can switch between <b>server</b> files (via the select element) and your own <b>local</b> files
                (via the File System). Selecting one will replace the other.
            </p>

            <p>Two versions of KML files are generated:</p>
            <ul>
                <li>One includes field names and values as <b>ExtendedData</b>, using <code>&lt;Data&gt;</code> and
                    <code>&lt;value&gt;</code> elements.
                </li>
                <li>The other embeds all fields in a <b>Description</b> element with HTML formatting, suitable for
                    platforms like Google Maps.</li>
            </ul>
        </div>
    </div>
    <div id="downloadLinks" class="flex bg"></div>
    <div class="flex">
        <p id="featureCount"></p>
    </div>
    <div id="preview" class="flex"></div>

    <script>
        let fullGeoJSON = null;
        let show_ConvertPreviws = false;
        const maps_ParentFolder = '../imgMedia/maps';
        const maps_PlacesFolder = `${maps_ParentFolder}/map_places`;

        // Populate the select element with CSV file(s) from the server
        let csv_FilesList = [];
        fetch(`${maps_PlacesFolder}/index_csv.json`)
            .then(response => response.json())
            .then(data => {
                csv_FilesList = data;

                const selector = document.getElementById('Server_CSVFile');
                data.forEach((filename, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = filename;
                    selector.appendChild(option);
                });
            });

        // Load the CSV file for filtering and conversion
        document.getElementById("Server_CSVFile").addEventListener("change", function () {
            const index = parseInt(this.value);
            file_Name = csv_FilesList[index];
            if (!file_Name) return alert("Please select a .csv file first.");
            server_fileURL = `${maps_PlacesFolder}/${file_Name}`;

            fetch(server_fileURL)
                .then(response => response.text())
                .then(csvText => {
                    fullGeoJSON = parseCSVToGeoJSON(csvText);
                    if (!fullGeoJSON) return;

                    const user_Input = document.getElementById('User_CSVFile');
                    if (user_Input) user_Input.value = '';
                    show_ConvertPreviws = true;
                    populateFilters(fullGeoJSON.features);
                    showPreview(fullGeoJSON.features);
                    createDownloadLink(fullGeoJSON);
                });
        });

        // Local CSV file from File System 
        function convert_CSVToGeoJSON() {
            const input = document.getElementById('User_CSVFile');
            const file = input.files[0];
            if (!file) return alert("Please select a .csv file first.");
            const reader = new FileReader();
            reader.onload = function (event) {
                fullGeoJSON = parseCSVToGeoJSON(event.target.result);
                if (!fullGeoJSON) return;

                const server_input = document.getElementById("Server_CSVFile");
                if (server_input) server_input.selectedIndex = 0;
                show_ConvertPreviws = false;
                populateFilters(fullGeoJSON.features);
                showPreview(fullGeoJSON.features);
                createDownloadLink(fullGeoJSON);
            };

            reader.readAsText(file);
        }

        function parse____CSVToGeoJSON(csvText) {
            const parsed = Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true
            });

            const rows = parsed.data;
            // convert all fields to lowercase
            const headers = parsed.meta.fields.map(h => h.trim());

            const latKeys = ['lat', 'Lat', 'LAT', 'latitude', 'Latitude', 'LATITUDE'];
            const lonKeys = ['lon', 'Lon', 'LON', 'lng', 'Lng', 'LNG', 'long', 'Long', 'LONG', 'longitude', 'Longitude', 'LONGITUDE'];
            const latKey = headers.find(h => latKeys.includes(h.trim()));
            const lonKey = headers.find(h => lonKeys.includes(h.trim()));

            if (!latKey || !lonKey) {
                alert("Latitude or Longitude column not found.");
                return null;
            }

            const features = rows.map(row => {
                const lat = parseFloat(row[latKey]);
                const lon = parseFloat(row[lonKey]);
                const props = {};

                headers.forEach(key => {
                    // used only for lat/lon comparison
                    const normalizedKey = key.trim().toLowerCase();
                    if (normalizedKey !== latKey.toLowerCase() && normalizedKey !== lonKey.toLowerCase()) {
                        const raw = row[key] || '';
                        const normalized = raw.replace(/""/g, '"');
                        try {
                            props[key] = normalized.startsWith('[')
                                ? JSON.parse(normalized)
                                : normalized;
                        } catch {
                            props[key] = normalized;
                        }
                    }
                });

                return (!isNaN(lat) && !isNaN(lon)) ? {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [lon, lat]
                    },
                    properties: props
                } : null;
            }).filter(f => f !== null);

            return {
                type: "FeatureCollection",
                features
            };
        }

        let invalidCount = 0;
        function parseCSVToGeoJSON(csvText) {
            // Reser for new file conversion
            invalidCount = 0;
            const parsed = Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true
            });

            const rows = parsed.data;
            const headers = parsed.meta.fields.map(h => h.trim());

            const latKeys = ['lat', 'Lat', 'LAT', 'latitude', 'Latitude', 'LATITUDE'];
            const lonKeys = ['lon', 'Lon', 'LON', 'lng', 'Lng', 'LNG', 'long', 'Long', 'LONG', 'longitude', 'Longitude', 'LONGITUDE'];
            const latKey = headers.find(h => latKeys.includes(h.trim()));
            const lonKey = headers.find(h => lonKeys.includes(h.trim()));

            if (!latKey || !lonKey) {
                alert("Latitude or Longitude column not found.");
                return null;
            }

            let validFeatures = [];

            rows.forEach(row => {
                const lat = parseFloat(row[latKey]);
                const lon = parseFloat(row[lonKey]);

                if (isNaN(lat) || isNaN(lon)) {
                    invalidCount++;
                    return;
                }

                const props = {};
                headers.forEach(key => {
                    const normalizedKey = key.trim().toLowerCase();
                    if (normalizedKey !== latKey.toLowerCase() && normalizedKey !== lonKey.toLowerCase()) {
                        const raw = row[key] || '';
                        const normalized = raw.replace(/""/g, '"');
                        try {
                            props[key] = normalized.startsWith('[')
                                ? JSON.parse(normalized)
                                : normalized;
                        } catch {
                            props[key] = normalized;
                        }
                    }
                });

                validFeatures.push({
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [lon, lat]
                    },
                    properties: props
                });
            });

            if (invalidCount > 0) {
                alert(`⚠️ ${invalidCount} row(s) were skipped due to invalid Latitude/Longitude values.\nThey will NOT be included in the output.\nConsider using the CSV Validator for detailed inspection.`);
            }

            return {
                type: "FeatureCollection",
                features: validFeatures
            };
        }

        // Check Case-Insensitive property names
        function hasPropertyCI(obj, targetKey) {
            return Object.keys(obj).some(k => k.toLowerCase() === targetKey.toLowerCase());
        }

        // Global array with actual key name used in the object
        const keyMap = {};

        // returns the actual key name used in the object
        function getActualKey(obj, targetKey) {
            const entry = Object.keys(obj).find(k => k.toLowerCase() === targetKey.toLowerCase());
            return entry || null;
        }

        function populateFilters(features) {
            // Hide information
            hide_information();
            // Reset before checking
            show_ConvertPreviws = false;
            // Check if fields for filtering exists in the CSV file (type/Type, region/Region, etc.)
            const hasType = features.some(f => hasPropertyCI(f.properties, 'type'));
            const hasRegion = features.some(f => hasPropertyCI(f.properties, 'region'));
            const hasPassages = features.some(f => hasPropertyCI(f.properties, 'passages'));

            // Hide select elements for non-existing filtering fields
            document.getElementById('typeFilterContainer').style.display = hasType ? 'block' : 'none';
            document.getElementById('regionFilterContainer').style.display = hasRegion ? 'block' : 'none';
            document.getElementById('bookFilterContainer').style.display = hasPassages ? 'block' : 'none';

            console.log(hasType)

            if (hasType || hasRegion || hasPassages) {
                show_ConvertPreviws = true;
            }

            //Populate the global variable with actual key name
            const sampleProps = features[0]?.properties || {};
            ['type', 'region', 'passages'].forEach(k => {
                const actual = getActualKey(sampleProps, k);
                if (actual) keyMap[k] = actual;
            });

            const typeSet = new Set();
            const bookSet = new Set();
            const regionSet = new Set();

            features.forEach(f => {
                const types = Array.isArray(f.properties[keyMap['type']]) ? f.properties[keyMap['type']] : [f.properties[keyMap['type']]];
                types.forEach(t => t && typeSet.add(t));

                const passages = Array.isArray(f.properties[keyMap['passages']]) ? f.properties[keyMap['passages']] : [];
                passages.forEach(p => {
                    const prefix = p.split('.')[0];
                    if (prefix) bookSet.add(prefix);
                });
                const region = f.properties[keyMap['region']];
                if (region) regionSet.add(region);

            });

            const bookFilter = document.getElementById('bookFilter');
            const typeFilter = document.getElementById('typeFilter');
            const regionFilter = document.getElementById('regionFilter');
            bookFilter.innerHTML = '<option value="">(All)</option>' + [...bookSet].sort().map(b => `<option value="${b}">${b}</option>`).join('');
            typeFilter.innerHTML = '<option value="">(All)</option>' + [...typeSet].sort().map(t => `<option value="${t}">${t}</option>`).join('');
            regionFilter.innerHTML = '<option value="">(All)</option>' + [...regionSet].sort().map(r => `<option value="${r}">${r}</option>`).join('');

            typeFilter.onchange = () => applyFilters();
            bookFilter.onchange = () => applyFilters();
            regionFilter.onchange = () => applyFilters();

        }

        // Check the name of filtering fields indepandent of case
        function getPropertyCI(obj, targetKey) {
            const entry = Object.entries(obj).find(([k]) => k.toLowerCase() === targetKey.toLowerCase());
            return entry?.[1];
        }

        function applyFilters() {
            const bookVal = document.getElementById('bookFilter').value;
            const typeVal = document.getElementById('typeFilter').value;
            const regionVal = document.getElementById('regionFilter').value;

            const filtered = fullGeoJSON.features.filter(f => {
                const passagesRaw = getPropertyCI(f.properties, keyMap['passages']);
                const passages = Array.isArray(passagesRaw) ? passagesRaw : [];

                const typeRaw = getPropertyCI(f.properties, keyMap['type']);
                const types = Array.isArray(typeRaw) ? typeRaw : [typeRaw];

                const region = getPropertyCI(f.properties, keyMap['region']) || '';

                const bookMatch = !bookVal || passages.some(p => p.startsWith(bookVal + '.'));
                const typeMatch = !typeVal || types.includes(typeVal);
                const regionMatch = !regionVal || region === regionVal;

                return bookMatch && typeMatch && regionMatch;
            });

            showPreview(filtered);
            createDownloadLink({ type: "FeatureCollection", features: filtered });
        }

        function showPreview(features) {
            const valid_Features = features.length;
            const total_Features = valid_Features + invalidCount;
            const count = document.getElementById('featureCount');
            const preview = document.getElementById('preview');
            if (show_ConvertPreviws) {
                const sample = features.slice(0, 5).map((f, i) => {
                    return `Feature ${i + 1}:\n` +
                        `  Name: ${f.properties.name || f.properties.Name || '(no name)'}\n` +
                        `  Region: ${f.properties[keyMap['region']] || '(no region)'}\n` +
                        `  Type: ${JSON.stringify(f.properties[keyMap['type']])}\n` +
                        `  Passages: ${JSON.stringify(f.properties[keyMap['passages']])}\n` +
                        `  Coordinates: [${f.geometry.coordinates.join(', ')}]`;
                }).join('\n\n');

                preview.innerHTML = `<pre>${sample || 'No matching features.'}</pre>`;
                count.innerHTML = `5 partial previews of <b>totally</b> ${total_Features} features, of which <b>invalid:</b> ${invalidCount} and <b>valid:</b> ${valid_Features}.`;
            } else {
                preview.innerHTML = '';
                count.innerHTML = `The output includes ${valid_Features} <b>valid</b> features of totally ${total_Features} <b>features</b>. ${invalidCount} <b>invalid</b> features are excluded.`;
            }
        }

        function createDownloadLink(geojson) {
            const container = document.getElementById('downloadLinks');
            container.innerHTML = '';

            // GeoJSON
            const geoBlob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const geoUrl = URL.createObjectURL(geoBlob);
            const geoLink = document.createElement('a');
            geoLink.href = geoUrl;
            geoLink.download = 'filtered.geojson';
            geoLink.textContent = 'Download GeoJSON';
            geoLink.style.display = 'block';
            container.appendChild(geoLink);

            // Plain KML
            const plainKML = convert_GeoJSON_To_KML(geojson, false);
            const plainBlob = new Blob([plainKML], { type: 'application/vnd.google-earth.kml+xml' });
            const plainUrl = URL.createObjectURL(plainBlob);
            const plainLink = document.createElement('a');
            plainLink.href = plainUrl;
            plainLink.download = 'filtered_data.kml';
            plainLink.textContent = 'Download Extended Data KML';
            plainLink.style.display = 'block';
            container.appendChild(plainLink);

            // Rich KML
            const richKML = convert_GeoJSON_To_KML(geojson, true);
            const richBlob = new Blob([richKML], { type: 'application/vnd.google-earth.kml+xml' });
            const richUrl = URL.createObjectURL(richBlob);
            const richLink = document.createElement('a');
            richLink.href = richUrl;
            richLink.download = 'filtered_html.kml';
            richLink.textContent = 'Download HTML Description KML';
            richLink.style.display = 'block';
            container.appendChild(richLink);
        }

        function convert_GeoJSON_To_KML(geojson, rich = false) {
            const placemarks = geojson.features.map(f => {
                const [lon, lat] = f.geometry.coordinates;
                const props = f.properties || {};

                let content = '';
                if (rich) {
                    // Rich HTML table inside CDATA
                    content = '<table border="1" cellpadding="4">';
                    Object.entries(props).forEach(([key, value]) => {
                        const val = Array.isArray(value) ? value.join(', ') : value;
                        content += `<tr><th>${key}</th><td>${val}</td></tr>`;
                    });
                    content += '</table>';
                    content = `<description><![CDATA[${content}]]></description>`;
                } else {
                    // Structured ExtendedData
                    const extended = Object.entries(props).map(([key, value]) => {
                        const val = Array.isArray(value) ? JSON.stringify(value) : value;
                        return `<Data name="${key}"><value>${val}</value></Data>`;
                    }).join('\n');
                    content = `<ExtendedData>\n${extended}\n</ExtendedData>`;
                }

                return `
<Placemark>
  <name>${name}</name>
  ${content}
  <Point><coordinates>${lon},${lat}</coordinates></Point>
</Placemark>`;
            }).join('\n');

            return `<` + `?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
${placemarks}
</Document>
</kml>`;
        }

        document.addEventListener("DOMContentLoaded", function () {
            const toggleButton = document.getElementById("ShowHide");
            const infoSection = document.getElementById("info");

            toggleButton.addEventListener("click", function () {
                const isHidden = infoSection.style.display === "none";

                // Toggle visibility
                infoSection.style.display = isHidden ? "block" : "none";

                // Toggle class
                toggleButton.classList.toggle("show", !isHidden);
                toggleButton.classList.toggle("hide", isHidden);
            });

            // Initial state
            infoSection.style.display = "block";
        });
        // Hide information with loading
        function hide_information() {
            const el = document.getElementById("ShowHide");
            el.classList.remove('hide');
            el.classList.add('show');
            document.getElementById("info").style.display = 'none';
        }
    </script>

</body>

</html>