<!DOCTYPE html>
<html lang="en">

<head>
    <title>Convert KML to GeoJSON with ExtendedData | Digital Periegesis</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="language" content="en" />
    <meta name="creator" content="Public Sphere" />
    <meta name="title" content="Convert KML to GeoJSON with ExtendedData | Digital Periegesis" />
    <meta name="description"
        content="Upload a KML file with ExtendedData and convert it to GeoJSON. Choose Compact or Pretty output formats based on file size and formatting preferences." />
    <meta name="keywords"
        content="KML to GeoJSON, convert KML, ExtendedData, Compact output, Pretty output, geographic data, Digital Periegesis" />

    <meta property="og:type" content="website" />
    <meta property="og:title" content="Convert KML to GeoJSON with ExtendedData | Digital Periegesis" />
    <meta property="og:description"
        content="Convert KML files with ExtendedData to GeoJSON format. Supports Compact and Pretty output styles." />
    <meta property="og:site_name" content="Digital Periegesis" />
    <meta property="og:url" content="https://www.periegesis.org/en/map_tools.php?p=convert-kml-to-geojson" />

    <link rel="icon" type="image/svg+xml" href="../images/logo/favicon.svg">
    <link rel="canonical" href="https://www.periegesis.org/en/map_tools.php?p=convert-kml-to-geojson" />

    <style>
        html {
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;
            padding: 0;
            margin: 0;
            margin-bottom: 4rem;
        }

        h3 {
            padding: 0;
            margin: 0;
        }

        .header {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0.5rem 20%;
            background-color: #003D7A;
            color: #ffffffcc;
        }

        .fixed {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
        }

        .fixed a {
            color: #ffffffcc;
            text-decoration: none;
        }

        .fixed a:hover {
            color: #ffffff;
        }

        #dropzone {
            border: 2px dashed #ffffffcc;
            padding: 1em;
            text-align: center;
        }

        .flex {
            display: flex;
            justify-content: space-around;
            margin: 1rem 10%;
        }

        input,
        button {
            padding: 0.5rem;
        }

        .hide {
            display: none;
        }

        .container {
            width: 100%;
            max-width: 1024px;
            padding: 1rem;
            margin: 0 auto;
            background-color: #f6f6f6;
            border: 1px solid #ddd;
            line-height: 1.5;
        }

        pre {
            background-color: #f6f6f6;
            border: 1px solid #dddddd;
            padding: 1rem;
            max-width: 100%;
            overflow: auto;
        }

        #loadingContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
        }

        #loadingContainer img {
            display: none;
        }
    </style>
</head>

<body>
    <div>
        <div class="fixed">
            <a title="Home to Digital Periegesis" href="index.php">dp</a><br>
            <a title="Search in Maps" href="map_search.php">SM</a>
        </div>
        <form id="kmlForm" class="header">
            <label for="kmlFile">Choose KML file:
                <input type="file" id="kmlFile" accept=".kml" required>
            </label>
            <fieldset>
                <legend>Output Format</legend>
                <label>
                    <input type="radio" name="format" value="compact" checked> Compact (in a single-line)
                </label><br>
                <label><input type="radio" name="format" value="pretty"> Pretty (for file size < 25MB)</label>
            </fieldset>
            <fieldset>
                <legend>If Metadat Contains File Version</legend>
                <label><input type="checkbox" name="AddFileVersion_Geo"> Add to both GeoJson & CSV</label><br>
                <label><input type="checkbox" name="AddFileVersion_CSV"> Add only to CSV</label>
            </fieldset>
            <button type="submit">Convert to GeoJSON</button>
        </form>
    </div>

    <div class="flex">
        <div>
            <h2>Convert KML to GeoJSON and, <small>for Point Geometries</small>, to CSV</h2>
            <div class="container">
                <h3>Conversion</h3>
                <p>Upload a KML file with <b>ExtendedData</b> and <b>Geometry</b> of types: Point, LineString, Polygon
                    or MultiGeometry.</p>
                <p>The tool will extract and convert geometries and extended data to a GeoJSON file.</p>
                <ul>
                    <li><b>Compact</b> outputs the conversion content in a single line.</li>
                    <li><b>Pretty</b> outputs feature properties in new lines but collapses all coordinates in a single
                        line.
                    </li>
                    <li>If the file size is greater than 25MB, the Compact output is automatically used.</li>
                </ul>
                <p>CSV export supports only <b>Point</b> geometries, which are converted to Lon and Lan.</p>
                <h3>If the KML File contains Metadata</h3>
                <p>If your KML file contains <b>metadata</b>, as ExtendedData, immediately under the Document structure
                    (before any Placemark):</p>
                <ul>
                    <li>Metadata is converted in GeoJson files to <b>Properties</b>, immediately under the
                        FeatureCollection structure, before Features.</li>
                    <li>Metadata cannot be saved in CSV files.</li>
                </ul>
                <h3>Add File Version or Last Updated Date</h3>
                <p>If metadata contains the case insensitive name <b>Updated</b>
                    or <b>Version</b>, you can add it as feature property in GeoJson files and as Field Name in CSV
                    files, which makes it visible in all popups.</p>
                <ul>
                    <li>Check <b>Add to both GeoJson & CSV</b> to add verion in both files. Note that in the <b>Search
                            in Maps</b> tool, version is visible in popups if it exists in the matadata of the GeoJson
                        file, so you don't need to include it as property of every feature.</li>
                    <li>Check <b>Add only to CSV</b> file to add the name as the first field name, with its value
                        repeated in every row.</li>
                </ul>

            </div>

        </div>
    </div>

    <p id="loadingContainer">
        <img id="loadingImg" src="../imgPG/loading_blue.gif"> <span id="loadingText"></span>
    </p>

    <div class="flex">
        <button id="download_Geo_Btn" class="hide">Download GeoJSON</button>
        <button id="download_CSV_Btn" class="hide">Download CSV</button>
    </div>
    <div id="previewInfo"></div>
    <pre id="outputPreview" class="hide"></pre>


    <script>
        const preview = document.getElementById("outputPreview");
        const previewInfo = document.getElementById("previewInfo");
        const geo_btn = document.getElementById("download_Geo_Btn");
        const csv_btn = document.getElementById("download_CSV_Btn");

        function showSpinner(message = 'Converting...') {
            document.getElementById('loadingImg').style.display = 'block';
            document.getElementById('loadingText').textContent = message;
        }

        function hideSpinner() {
            document.getElementById('loadingImg').style.display = 'none';
            document.getElementById('loadingText').textContent = '';
        }



        const max_SizeKB = 25000;
        let file_Size = 0;
        let fiel_Name = 'KML_to_Geo';
        let version_Sufix = '';

        // Get Format selector
        function getSelectedFormat() {
            return document.querySelector('input[name="format"]:checked').value;
        }
        let add_FileVersion_Geo = false;
        function get_AddFileVersion_Geo() {
            return document.querySelector('input[name="AddFileVersion_Geo"]').checked;
        }
        function get_AddFileVersion_CSV() {
            return document.querySelector('input[name="AddFileVersion_CSV"]').checked;
        }

        document.getElementById("kmlForm").addEventListener("submit", function (event) {
            event.preventDefault(); // prevent page reload

            const fileInput = document.getElementById("kmlFile");
            const file = fileInput.files[0];
            if (!file) return;

            // Reset for every new file
            version_Sufix = new Date().toISOString().split('T')[0];

            preview.textContent = '';
            preview.classList.add("hide");
            previewInfo.textContent = '';
            showSpinner();
            if (geo_btn) {
                geo_btn.classList.add("hide");
                geo_btn.onclick = null;
            }
            if (csv_btn) {
                csv_btn.classList.add("hide");
                csv_btn.onclick = null;
            }

            file_Size = file.size;
            fiel_Name = file.name.replace(/\.[^/.]+$/, "");
            const reader = new FileReader();
            reader.onload = function (e) {
                const kmlText = e.target.result;
                const geojson = convertKMLtoGeoJSON(kmlText);
                showPreview(geojson);
                enableDownload(geojson);

                // To CSV
                //======================================
                saveGeoJSONasCSV(geojson, fiel_Name);
            };
            reader.readAsText(file);
        });

        // Collapses all coordinates of all geometry types to a row
        function selectivePrettyPrint(obj) {
            const placeholderMap = new Map();
            let counter = 0;

            // Step 1: Replace large arrays with placeholders
            const jsonWithPlaceholders = JSON.stringify(obj, (key, value) => {
                if (key === "coordinates" && Array.isArray(value)) {
                    const id = `__COORD_${counter++}__`;
                    placeholderMap.set(id, JSON.stringify(value)); // compact version
                    return id;
                }
                return value;
            }, 2);

            // Step 2: Replace placeholders with compact arrays
            let finalJson = jsonWithPlaceholders;
            for (const [id, compact] of placeholderMap.entries()) {
                finalJson = finalJson.replace(`"${id}"`, compact);
            }

            return finalJson;
        }


        // Live Preview
        function showPreview(geojson) {
            //const preview = document.getElementById("outputPreview");
            //const previewInfo = document.getElementById("previewInfo");
            const sample = geojson.features.slice(0, 5);

            const jsonText = selectivePrettyPrint(sample);

            preview.textContent = jsonText;
            preview.classList.remove("hide");
            previewInfo.textContent = `5 preview feature of tatally ${geojson.features.length} features.`;
            hideSpinner();
        }

        // Download Button
        function enableDownload(geojson) {
            const format = getSelectedFormat();
            let jsonText;

            if (format === "pretty" && file_Size < max_SizeKB * 1024) {
                jsonText = selectivePrettyPrint(geojson);
            } else {
                jsonText = JSON.stringify(geojson);
            }

            const blob = new Blob([jsonText], { type: "application/json" });

            const url = URL.createObjectURL(blob);

            geo_btn.onclick = () => {
                const a = document.createElement("a");
                a.href = url;
                a.download = `${fiel_Name}_${version_Sufix}.geojson`;
                a.click();
            };
            geo_btn.classList.remove("hide");
        }

        function remove_lines_spaces(txt) {
            if (typeof txt !== 'string') return '';
            return txt.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
        }

        // Converter Function
        function convertKMLtoGeoJSON(kmlText) {
            const parser = new DOMParser();
            const kmlDom = parser.parseFromString(kmlText, "text/xml");

            add_FileVersion_Geo = get_AddFileVersion_Geo();

            console.log('add_FileVersion_Geo: ', add_FileVersion_Geo)

            // Extract metadata (if exists)
            const metadata = {};
            const insert_FileVersion = {};
            if (kmlDom.querySelectorAll('Document > ExtendedData').length) {
                kmlDom.querySelectorAll('Document > ExtendedData > Data').forEach(data => {
                    const name = data.getAttribute('name');
                    const value = remove_lines_spaces(data.querySelector('value')?.textContent.trim());
                    if (name && value) metadata[name] = value;
                    if (name.toLowerCase() === 'updated' || name.toLowerCase() === 'version') {
                        version_Sufix = value;
                        if (add_FileVersion_Geo) {
                            insert_FileVersion[name] = value;
                        }
                    }
                });
            }

            // Build base GeoJSON
            const geojson = {
                type: "FeatureCollection",
                ...(Object.keys(metadata).length ? { properties: metadata } : {}),
                features: []
            };

            // Extract features
            const placemarks = kmlDom.getElementsByTagName("Placemark");
            for (let placemark of placemarks) {
                const geometry = extractGeometry(placemark);
                //const properties = extractExtendedData(placemark);
                const properties = { ...insert_FileVersion, ...extractExtendedData(placemark) };
                geojson.features.push({
                    type: "Feature",
                    geometry,
                    properties
                });
            }
            return geojson;
        }

        // Extracts Extended Data as feature properties
        function extractExtendedData(placemark) {
            const data = {};
            const extendedData = placemark.getElementsByTagName("ExtendedData")[0];
            if (!extendedData) return data;

            const dataElements = extendedData.getElementsByTagName("Data");
            for (let item of dataElements) {
                const name = item.getAttribute("name");
                const value = item.getElementsByTagName("value")[0]?.textContent || "";
                data[name] = value;
            }

            return data;
        }


        // Call Geometry Extractors
        // Each function will handle one geometry type and return a GeoJSON-compatible object.
        function extractGeometry(placemark) {

            if (placemark.getElementsByTagName("MultiGeometry").length) {
                const polygons = placemark.getElementsByTagName("Polygon");
                if (polygons.length > 1) return extractMultiPolygon(placemark);
                return extractMultiGeometry(placemark); // fallback for mixed geometries
            }

            if (placemark.getElementsByTagName("Polygon").length) return extractPolygon(placemark);
            if (placemark.getElementsByTagName("LineString").length) return extractLineString(placemark);
            if (placemark.getElementsByTagName("Point").length) return extractPoint(placemark);
            return null;


        }

        // 1. Point
        function extractPoint(placemark) {
            const coordsText = placemark.getElementsByTagName("Point")[0]?.getElementsByTagName("coordinates")[0]?.textContent;
            if (!coordsText) return null;

            const [lon, lat] = coordsText.trim().split(",").map(Number);
            return {
                type: "Point",
                coordinates: [lon, lat]
            };
        }

        // 2. LineString
        function extractLineString(placemark) {
            const coordsText = placemark.getElementsByTagName("LineString")[0]?.getElementsByTagName("coordinates")[0]?.textContent;
            if (!coordsText) return null;

            const coordinates = coordsText.trim().split(/\s+/).map(pair => {
                const [lon, lat] = pair.split(",").map(Number);
                return [lon, lat];
            });

            return {
                type: "LineString",
                coordinates
            };
        }

        // 3. Polygon
        function extractPolygon(placemark) {
            const coordsText = placemark.getElementsByTagName("Polygon")[0]?.getElementsByTagName("coordinates")[0]?.textContent;
            if (!coordsText) return null;

            const coordinates = coordsText.trim().split(/\s+/).map(pair => {
                const [lon, lat] = pair.split(",").map(Number);
                return [lon, lat];
            });

            return {
                type: "Polygon",
                coordinates: [coordinates] // GeoJSON expects an array of linear rings
            };
        }

        //  4. MultiGeometry
        function extractMultiGeometry(placemark) {
            const multi = placemark.getElementsByTagName("MultiGeometry")[0];
            if (!multi) return null;

            const geometries = [];
            for (let tag of ["Point", "LineString", "Polygon"]) {
                const elements = multi.getElementsByTagName(tag);
                for (let el of elements) {
                    const tempPlacemark = document.createElement("Placemark");
                    tempPlacemark.appendChild(el.cloneNode(true));
                    const geom = extractGeometry(tempPlacemark); // recursive call
                    if (geom) geometries.push(geom);
                }
            }

            return {
                type: "GeometryCollection",
                geometries
            };
        }

        // 5. Convert to MultiPolygon
        // If all `<Polygon>` elements belong to the same region, convert them into a single GeoJSON `MultiPolygon`.

        function extractMultiPolygon(placemark) {
            const polygons = placemark.getElementsByTagName("Polygon");
            const multiCoordinates = [];

            for (let polygon of polygons) {
                const coordsText = polygon.getElementsByTagName("coordinates")[0]?.textContent;
                if (!coordsText) continue;

                const ring = coordsText.trim().split(/\s+/).map(pair => {
                    const [lon, lat] = pair.split(",").map(Number);
                    return [lon, lat];
                });

                multiCoordinates.push([ring]); // each polygon is a separate linear ring group
            }

            return {
                type: "MultiPolygon",
                coordinates: multiCoordinates
            };

        }

        // To CSV
        // ===================================
        function geojsonToCSV(geojson) {
            const features = geojson.features || [];

            // Stop if any feature is not a Point
            for (let feature of features) {
                if (feature.geometry?.type !== "Point") {
                    // console.warn("CSV export supports only Point geometries.");
                    return null; // stop conversion
                }
            }

            let version_data = {};
            let versionKey = '';

            if (add_FileVersion_Geo === false) {
                const add_FileVersion_CSV = get_AddFileVersion_CSV();

                if (add_FileVersion_CSV) {
                    // Get metadate form geojson the file
                    version_data = geojson.properties || {};

                    // Fileter for "updated" or "version" (case-insensitive), if they exists
                    versionKey = Object.keys(version_data).filter(
                        key => key.toLowerCase() === "updated" || key.toLowerCase() === "version"
                    );
                }
            }

            // Determine property keys from features
            const featureProps = new Set();
            for (const f of features) {
                Object.keys(f.properties || {}).forEach(k => featureProps.add(k));
            }

            // Prepare header
            const headers = [...versionKey, ...featureProps, "Lon", "Lat"];
            // const headers = [...featureProps, "Lon", "Lat"];
            const rows = [headers.join(",")];

            // Build rows
            for (const feature of features) {
                const props = feature.properties || {};
                const geom = feature.geometry || {};
                const coords = geom.type === "Point" ? geom.coordinates : [null, null];
                const row = headers.map(h => {
                    if (version_data[h] !== undefined) return `"${version_data[h].replace(/"/g, '""')}"`;
                    if (props[h] !== undefined) return `"${String(props[h]).replace(/"/g, '""')}"`;
                    if (h === "Lon") return coords[0];
                    if (h === "Lat") return coords[1];
                    return "";
                });
                rows.push(row.join(","));
            }

            return rows.join("\n");
        }

        function saveGeoJSONasCSV(geojson, baseName = "KML_to_CSV") {
            const csv = geojsonToCSV(geojson);
            if (!csv) return; // stop if conversion was aborted

            const blob = new Blob([csv], { type: "text/csv" });

            csv_btn.onclick = () => {
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = baseName + "_" + version_Sufix + ".csv";
                a.click();
            };
            csv_btn.classList.remove("hide");

        }

    </script>

</body>

</html>